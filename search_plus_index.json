{"./":{"url":"./","title":"序言","keywords":"","body":"istio-handbook istio 开发指南 Copyright © xcbeyond.cn 2021 all right reserved，powered by Gitbook Updated at 2021-09-05 12:47:59 "},"microservice/new-generation-microservices-architecture.html":{"url":"microservice/new-generation-microservices-architecture.html","title":"迎接新一代微服务架构","keywords":"","body":"迎接新一代微服务架构 微服务是近些年来软件架构中的热名词，也是一个很大的概念，不同人对它的理解都各不相同，甚至在早期微服务架构中出现了一批四不像的微服务架构产品，有人把单纯引入 Spring Boot、Spring Cloud 等框架的应用服务也称之为微服务架构，但这却只是将它作为服务的 Web 容器而已。 随着微服务的火热，越来越多的团队开始实践，将微服务纷纷落地，并投入生产。但随着微服务规模的不断壮大，每增加一个微服务，就可能会增加一些依赖的基础设施和第三方的配置，比如 Kafka 、Redis 实例等，相应 CI/CD 的配置也会增加或调整。 同时随着微服务数量增多、业务复杂性的提升及需求的多样性等（如，对接第三方异构系统等），服务间通信的错综复杂，一步步地将微服务变得更加臃肿，服务治理也是难上加难，而这些问题在单体架构中是很容易解决的。为此，有人开始怀疑当初微服务化是否是明智之选，甚至考虑回归到传统单体应用。 正如下图所示，PPT 中的微服务总是美好的，但现实中的微服务却是一团糟糕，想甩甩不掉，越看越糟心。难道就没有办法了么？ 图 2.1.1：现实中和PPT中的微服务对比 1、传统微服务架构面临的挑战 面对上述暴露出的问题，并在传统微服务架构下，经过实践的不断冲击，面临了更多新的挑战，综上所述，产生这些问题的原因有以下这几点： 过于绑定特定技术栈。 当面对异构系统时，需要花费大量精力来进行代码的改造，不同异构系统可能面临不同的改造。 代码侵入度过高。 开发者往往需要花费大量的精力来考虑如何与框架或 SDK 结合，并在业务中更好的深度融合，对于大部分开发者而言都是一个高曲线的学习过程。 多语言支持受限。 微服务提倡不同组件可以使用最适合它的语言开发，但是传统微服务框架，如 Spring Cloud 则是 Java 的天下，多语言的支持难度很大。这也就导致在面对异构系统对接时的无奈，或选择退而求其次的方案了。 老旧系统维护难。 面对老旧系统，很难做到统一维护、治理、监控等，在过度时期往往需要多个团队分而管之，维护难度加大。 上述这些问题在传统微服务架构中都是在所难免，我们都知道技术演进来源于实践中不断的摸索，将功能抽象、解耦、封装、服务化。 随着传统微服务架构暴露出的这些问题，将迎来新的挑战，让大家纷纷寻找其他解决方案。 2、迎来新一代微服务架构 为了解决传统微服务面临的问题，以应对全新的挑战，微服务架构也进一步演化，最终催生了Service Mesh 的出现，迎来了新一代微服务架构，也被称为“下一代微服务”。为了更好地理解 Service Mesh 的概念和存在的意义，我们来回顾一下这一演进过程。 1.1 耦合阶段 在微服务架构中，服务发现、负载均衡、熔断等能力是微服务架构中重要的组成部分。微服务化之后，服务更加的分散，复杂度变得更高，起初开发者将诸如熔断、超时等功能和业务代码封装在一起，使服务具备了网络管控的能力，如下图所示。 图 2.1.2：耦合阶段 这种方案虽然易于实现，但从设计角度来讲却存在一定的缺陷。 基础设施功能（如，服务发现，负载均衡、熔断等）和业务逻辑高度耦合。 每个微服务都重复实现了相同功能的代码。 管理困难。如果某个服务的负载均衡发生变化，则调用它的相关服务都需要更新变化。 开发者不能集中精力只关注于业务逻辑开发。 1.2 公共库 SDK 基于上面存在的问题，很容易会想到将基础设施功能设计为一个公共库 SDK，让服务的业务逻辑与这些公共功能降低耦合度，提高重复利用率，更重要的是开发者只需要关注公共库 SDK 的依赖及使用，而不必关注实现这些公共功能，从而更加专注于业务逻辑的开发，比如 Spring Cloud 框架是类似的方式。如下图所示： 图 2.1.3：公共库SDK阶段 实际上即便如此，它仍然有一些不足之处。 这些公共库 SDK 存在较为陡峭的学习成本，需要耗费开发人员一定的时间和人力与现有系统集成，甚至需要考虑修改现有代码进行整合。 这些公共库 SDK 一般都是通过特定语言实现，缺乏多语言的支持，在对现有系统整合时有一定的局限性。 公共库 SDK 的管理和维护依然需要耗费开发者的大量精力，并需专门人员来进行管理维护。 1.3 Sidecar 模式 有了上面公共库 SDK 的启发，加上跨语言问题、更新后的发布和维护等问题，人们发现更好的解决方案是把它作为一个代理，服务通过这个透明的代理完成所有流量的控制。 这就是典型的 Sidecar 代理模式，也被翻译为\"边车\"代理，它作为与其他服务通信的桥梁，为服务提供额外的网络特性，并与服务独立部署，对服务零侵入，更不会受限于服务的开发语言和技术栈，如下图所示。 图 2.1.4：Sidecar模式阶段 以 Sidecar 模式进行通信代理，实现了基础实施层与业务逻辑的完全隔离，在部署、升级时带来了便利，做到了真正的基础设施层与业务逻辑层的彻底解耦。另一方面，Sidecar 可以更加快速地为应用服务提供更灵活的扩展，而不需要应用服务的大量改造。Sidecar 可以实现以下主要功能： 服务注册。 帮助服务注册到相应的服务注册中心，并对服务做相关的健康检查。 服务路由。 当应用服务调用其它服务时，Sidecar 可以帮助从服务发现中找到相应的服务地址，完成服务路由功能。 服务治理。 Sidecar 可以完全拦截服务进出的流量，并对其进行相应的调用链跟踪、熔断、降级、日志监控等操作，将服务治理功能集中在 Sidecar 中实现。 集中管控。 整个微服务架构体系下的所有服务完全可以通过 Sidecar 来进行集中管控，完成对服务的流控、下线等。 于是，应用服务终于可以做到跨语言开发、并更专注于业务逻辑的开发。 1.4 Service Mesh 把 Sidecar 模式充分应用于一个庞大的微服务架构系统，为每个应用服务配套部署一个 Sidecar 代理，完成服务间复杂的通信，最终就会得到一个如下图所示的网络拓扑结构，这就是 Service Mesh，又称之为“服务网格“。 图 2.1.5：Service Mesh阶段 至此，迎来了新一代微服务架构——Service Mesh，它彻底解决了传统微服务架构所面临的问题。 Copyright © xcbeyond.cn 2021 all right reserved，powered by Gitbook Updated at 2021-09-05 13:52:03 "},"servicemesh/introduction.html":{"url":"servicemesh/introduction.html","title":"Service Mesh 介绍","keywords":"","body":"Service Mesh 介绍 Service Mesh翻译为“服务网格”，作为服务间通信的基础设施层。轻量级高性能网络代理，提供安全的、快速的、可靠地服务间通讯，与实际应用部署一起，但对应用透明。应用作为服务的发起方，只需要用最简单的方式将请求发送给本地的服务网格代理，然后网格代理会进行后续的操作，如服务发现，负载均衡，最后将请求转发给目标服务。 Service Mesh目的是解决系统架构微服务化后的服务间通信和治理问题。服务网格由Sidecar节点组成，这个模式的精髓在于实现了数据面（业务逻辑）和控制面的解耦。具体到微服务架构中，即给每一个微服务实例同步部署一个Sidecar。 图 3.1.1：Service Mesh部署网络结构图 在Service Mesh部署网络结构图中，绿色方块为应用服务，蓝色方块为 Sidecar，应用服务之间通过Sidecar进行通信，整个服务通信形成图中的蓝色网络连线，图中所有蓝色部分就形成了Service Mesh。其具备如下主要特点： 应用程序间通讯的中间层 轻量级网络代理 应用程序无感知 解耦应用程序的重试/超时、监控、追踪和服务发现 Service Mesh 的出现解决了传统微服务框架中的痛点，使得开发人员专注于业务本身，同时，将服务通信及相关管控功能从业务中分离到基础设施层。 1、Service Mesh 功能 Service Mesh 作为微服务架构中负责网络通信的基础设施层，具备网络处理的大部分功能。下面列举了一些主要的功能： 动态路由。 可通过路由规则来动态路由到所请求的服务，便于不同环境、不同版本等的动态路由调整。 故障注入。 通过引入故障来模拟网络传输中的问题（如延迟）来验证系统的健壮性，方便完成系统的各类故障测试。 熔断。 通过服务降级来终止潜在的关联性错误。 安全。 在Service Mesh上实现安全机制（如TLS），并且很容易在基础设施层完成安全机制更新。 多语言支持。 作为独立运行且对业务透明的 Sidecar 代理，Service Mesh 很轻松地支持多语言的异构系统。 多协议支持。 同多语言一样，也支持多协议。 指标和分布式链路追踪。 概括起来，Service Mesh 主要体现在以下 4 个方面： 可见性： 运行时指标遥测、分布式跟踪。 可管理性： 服务发现、负载均衡、运行时动态路由等。 健壮性： 超时、重试、熔断等弹性能力。 安全性： 服务间访问控制、TLS 加密通信。 2、Service Mesh 解决的问题 从上述Service Mesh的定义看： 基础设施层是Service Mesh的定位，致力于解决微服务基础设施标准化、配置化、服务化和产品化的问题。 服务间通信是Service Mesh技术层面对的问题，对微服务屏蔽通信的复杂度，解决微服务的通信治理问题。 请求的可靠传递是Service Mesh的目标。 轻量级网络代理是Service Mesh的部署方式。 对应用程序透明是Service Mesh的亮点和特色，实现对业务无侵入。 综合上述，Service Mesh主要解决用户如下 3 个维度的痛点需求： 完善的微服务基础设施 通过将微服务通信下沉到基础设施层，屏蔽了微服务处理各种通信问题的复杂度，形成微服务之间的抽象协议层。开发者无需关心通信层的具体实现，也无需关注RPC通信（包含服务发现、负载均衡、流量调度、流量降级、监控统计等）的一切细节，真正像本地调用一样使用微服务，通信相关的一起工作直接交给Service Mesh。 语言无关的通信和链路治理 功能上，Service Mesh并没有提供任何新的特性和能力，Service Mesh提供的所有通信和服务治理能力在Service Mesh之前的技术中均能找到，比如Spring Cloud就实现了完善的微服务RPC通信和服务治理支持。 Service Mesh改变的是通信和服务治理能力提供的方式，通过将这些能力实现从各语言业务实现中解耦，下沉到基础设施层面，以一种更加通用和标准化的方式提供，屏蔽不同语言、不同平台的差异性，有利于通信和服务治理能力的迭代和创新，使得业务实现更加方便。 Service Mesh避免了多语言服务治理上的重复建设，通过Service Mesh语言无关的通信和服务治理能力，助力于多语言技术栈的效率提升。 通信和服务治理的标准化 微服务治理层面，Service Mesh是标准化、体系化、无侵入的分布式治理平台。 标准化方面，Sidecar成为所有微服务流量通信的约束标准，同时Service Mesh的数据平台和控制平面也通过标准协议进行交互。 体系化方面，从全局考虑，提供多维度立体的微服务可观测能力（Metric、Trace、Logging），并提供体系化的服务治理能力，如限流、熔断、安全、灰度等。 通过标准化，带来一致的服务治理体验，减少多业务之间由于服务治理标准不一致带来的沟通和转换成本，提升全局服务治理的效率。 3、Service Mesh 原理 Service Mesh 的核心是数据平面 Sidecar 与控制平面 Control Plane，如下图： 图 3.1.2：Service Mesh架构图 数据平面： Sidecar，与服务部署在一起的轻量级网络代理，用于实现服务框架的各项功能（如，服务发现、负载均衡、限流熔断等），让服务回归业务本质。 数据平台可以认为是将 Spring Cloud、Dubbo 等相关的微服务框架中通信和服务治理能力独立出来的一个语言无法的进程，并且更注重通用性和扩展性。在 Service Mesh 中，不再将数据平面代理视为一个个独立的组件，而是将这些代理连接在一起形成一个全局的分布式网格。 在传统的微服务架构中，各种服务框架的功能（如，服务发现、负载均衡、限流熔断等）代码逻辑或多或少的都需要耦合到服务实例的代码中，给服务实例增加了很多无关业务的代码，同时带来了一定的复杂度。 有了 Sidecar之后，服务节点只做业务逻辑自身的功能，服务之间的调用只需交给 Sidecar，由Sidecar 完成注册服务、服务发现、请求路由、熔断限流、日志统计等业务无关功能。 在这种新的微服务架构中，所有的 Sidecar 组成在一起，就形成了服务网格。那么这个大型的服务网格并不是完全自治的，它还需要一个统一的控制节点 Control Plane。 控制平面： 是用来从全局的角度上控制 Sidecar，相当于 Service Mesh 架构的大脑，控制着 Sidecar 来实现服务治理的各项功能。比如，它负责所有 Sidecar 的注册，存储统一的路由表，帮助各个 Sidecar 进行负载均衡和请求调度；它收集所有 Sidecar的监控信息和日志数据。 Copyright © xcbeyond.cn 2021 all right reserved，powered by Gitbook Updated at 2021-09-21 15:04:39 "},"servicemesh/framework-contrast.html":{"url":"servicemesh/framework-contrast.html","title":"Service Mesh 框架对比","keywords":"","body":"Service Mesh 框架对比 当前，业界主要有以下主要几种 Service Mesh 框架，下面进行详细的说明及对比。 1、Linkerd Linkerd 是 Buoyant 公司 2016 年率先开源的高性能网络代理，是业界的第一款 Service Mesh 框架。其主要用于解决分布式环境中服务之间通信面临的一些问题，如网络不可靠、不安全、延迟丢包等问题。 Linkerd 使用Scala 语言编写，运行于 JVM，底层基于 Twitter 的 Finagle 库，并对其做了相应的扩展。最主要的是 Linkerd 具有快速、轻量级、高性能等特点，每秒以最小的延迟及负载处理万级请求，易于水平扩展。除此之外，还有以下功能： 支持多平台：可运行于多种平台，比如 Kubernetes、DC/OS、Docker，甚至虚拟机或物理机。 无缝集成多种服务发现工具。 支持多协议，如 gRPC、HTTP/1.x、HTTP/2，甚至可通过 linkerd-tcp 支持 TCP 协议。 支持与第三方分布式追踪系统 Zipkin 集成。 灵活性、扩展性高，可通过其提供的接口开发自定义插件。 目前，Linkerd和Linkerd2并行开发，其情况如下： Linkerd：Linkerd使用Scala语言编写，运行于JVM，底层基于 Twitter 的Finagle库，并对其做了相应的扩展。 Linkerd2：使用Go语言和Rust语言完全重写了Linkerd，专门用于Kubernetes。 Linkerd本身是数据平面，负责将数据路由到目标服务，同时保证数据在分布式环境中传输是安全、可靠、快速的。另外，Linkerd还包括控制平面组件Namerd，通过控制平面Namerd实现中心化管理和存储路由规则、中心化管理服务发现配置、支持运行时动态路由以及暴露Namerd API管理接口。 图 3.2.1：Linkerd架构图 控制平面 是在Kubernetes特定命名空间中运行的一组服务。这些服务可以完成各种事情：聚集遥测数据，提供面向用户的 API，向数据平面代理提供控制数据等。 由以下部分组成： Controller：由public-api容器组成，该容器为CLI和dashboard提供接口 API。 Destination：数据平面中的每个代理都使用此组件来查找将请求发送到哪里。还用于获取服务配置信息，如：路由指标，重试和超时等。 Identity：该组件提供了证书的颁发，接受来自代理的CSRs并返回正确身份签名的证书。这些证书由代理在启动时获取，并且必须在代理准备就绪之前发出。随后，它们可用于Linkerd代理之间的任何连接以实现mTLS。 Proxy Injector：是一个注入程序，每次创建一个pod时，它都会接收一个webhook请求。该注入程序检查资源以查找特定于Linkerd的注释（linkerd.io/inject: enabled）。当存在该注释时，注入器将更改容器的规范，并添加 initContainer包含代理本身的以及附属工具。 Service Profile Validator：用于在保存新服务配置文件之前先对其进行验证。 Tap：从CLI和dashboard接收请求，以实时监视请求和响应。 数据平面 由轻量级代理组成，这些代理作为sidecar容器与服务代码的每个实例一起部署。为了将服务“添加”到Linkerd服务网格，必须重新部署该服务的Pod，以在每个 Pod 中包含数据平面代理。 2、Envoy 同Linkerd一样，Envoy也是一款高性能的网络代理，于 2016 年 10 月份有 Lyft 公司开源，为云原生应用而设计，可作为边界入口，处理外部流量，此外，也作为内部服务间通信代理，实现服务间可靠通信。Envoy的实现借鉴现有生产级代理及负载均衡器，如Nginx、HAProxy、硬件负载均衡器及云负载均衡器的实践经验，同时基于C++编写及 Lyft 公司生产实践证明，Envoy性能非常优秀、稳定。 Envoy既可用作独立代理层运行，也可作为Service Mesh架构中数据平面层，因此通常Envoy跟服务运行在一起，将应用的网络功能抽象化，Envoy提供通用网络功能，实现平台及语言无法性。除此之外，还有以下功能： 优先支持HTTP/2和gRPC，同时支持Websocket和 TCP 代理。 API 驱动的配置管理方式，支持动态管理、更新配置以及无连接和请求丢失的热重启功能。 L3/L4层过滤器形成Envoy核心的连接管理功能。 通过与多种指标收集工具及分布式追踪系统集成，实现运行时指标收集、分布式追踪，提供整个系统及服务的运行时可见性。 内存资源使用率低，Sidecar是Envoy最常用的部署模式。 3、Istio Istio是由Google、IBM和Lyft发起的开源的Service Mesh框架。该项目在 2017 年推出，并在 2018 年 7 月发布了 1.0 版本。 Istio是Service Mesh目前的实现的典型代表，如果Sidecar是整个Service Mesh的数据面，那么Istio主要在控制面上做了更多的改进，Istio使用Envoy作为Sidecar，控制面相关全部使用Golang编写，性能上有了很大的提升。 Istio 首先是一个服务网格，但是Istio又不仅仅是服务网格：在 Linkerd，Envoy 这样的典型服务网格之上，Istio提供了一个完整的解决方案，为整个服务网格提供行为洞察和操作控制，以满足微服务应用程序的多样化需求。 Istio在服务网络中统一提供了许多关键功能： 流量管理：控制服务之间的流量和 API 调用的流向，使得调用更可靠，并使网络在恶劣情况下更加健壮。 可观察性：了解服务之间的依赖关系，以及它们之间流量的本质和流向，从而提供快速识别问题的能力。 策略执行：将组织策略应用于服务之间的互动，确保访问策略得以执行，资源在消费者之间良好分配。策略的更改是通过配置网格而不是修改应用程序代码。 服务身份和安全：为网格中的服务提供可验证身份，并提供保护服务流量的能力，使其可以在不同可信度的网络上流转。 除此之外，Istio针对可扩展性进行了设计，以满足不同的部署需要。 平台支持：Istio旨在在各种环境中运行，包括跨云， 预置，Kubernetes，Mesos等。最初专注于Kubernetes，但很快将支持其他环境。 集成和定制：策略执行组件可以扩展和定制，以便与现有的ACL，日志，监控，配额，审核等解决方案集成。 这些功能极大的减少了应用程序代码，底层平台和策略之间的耦合，使微服务更容易实现。 图 3.2.2：Istio架构图 Istio架构图中各个子模块功能如下： Envoy：负责各个应用服务之间通信。 Pilot：管理和配置Envoy，提供服务发现、负载均衡和智能路由，保证弹性服务（服务超时次数、重试、熔断策略）。 Mixer：信息监控检查。 Istio-Auth：提供服务和服务、用户和服务之间的认证服务，实现访问控制，解决是谁访问的是哪个 API 的问题。 其中，图中的通信代理组件为Envoy，这是Istio原生引入的，但Linkerd也能够集成对接Istio。 4、Conduit Conduit于 2017 年 12 月发布，作为由 Buoyant 继Linkerd后赞助的另外一个开源项目，作为Linkerd面向Kubernetes的独立版本。Conduit旨在彻底简化用户在Kubernetes使用服务网格的复杂度，提高用户体验，而不是像Linkerd一样针对各种平台进行优化。 Conduit的主要目标是轻量级、高性能、安全并且非常容易理解和使用。同Linkerd和Istio，Conduit也包含数据平面和控制平面，其中数据平面由Rust语言开发，使得Conduit使用极少的内存资源，而控制平面由Go语言开发。Conduit依然支持Service Mesh要求的功能，而且还包括以下功能： 超级轻量级和极快的性能。 专注于支持Kubernetes平台，提高运行在Kubernetes平台上服务的可靠性、可见性及安全性。 支持gRPC、HTTP/2和HTTP/1.x请求及所有 TCP 流量。 Conduit以极简主义架构，以零配置理念为中心，旨在减少用户与Conduit的交互，实现开箱即用。 5、对比总结 下面对上述各种 Service Mesh 框架进行简单的比较汇总，见下表所示： 功能 Linkerd Envoy Istio Conduit 代理 Finagle + Jetty Envoy Envoy Conduit 熔断 支持。基于连接的熔断器Fast Fail和基于请求的熔断器Failure Accrual。 支持。通过特定准则，如最大连接数、 最大请求数、最大挂起请求数或者最大重试数的设定。 支持。通过特定准则，如最大连接数和最大请求数等的设定。 暂不支持。 动态路由 支持。通过设置Linkerd的dtab规则实现不同版本服务请求的动态路由。 支持。通过服务的版本或环境信息实现。 支持。通过服务的版本或环境信息实现。 暂不支持。 流量分流 支持。以增量和受控的方式实现分流。 支持。以增量和受控的方式实现分流。 支持。以增量和受控的方式实现分流。 暂不支持。 服务发现 支持。支持多种服务发现机制，如基于文件的服务发现、Consul、Zookeeper、Kubernetes等。 支持。通过提供平台无关的服务发现接口实现与不同服务发现工具集成。 支持。通过提供平台无关的服务发现接口实现与不同服务发现工具集成。 只支持Kubernetes。 负载均衡 支持。提供多种负载均衡算法。 支持。提供多种负载均衡算法，如Round Robin、加权最小请求、哈希环、Maglev等。 支持。提供多种负载均衡算法，如Round Robin、加权最小请求、哈希环、Maglev等。 支持。当前只有 HTTP 请求支持基于P2C + least-loaded的负载均衡算法。 安全通信 支持 TLS。 支持 TLS。 支持 TLS。 支持TLS。 访问控制 不支持。 不支持。 支持。基于RBAC的访问控制。 暂不支持。 可见性 分布式追踪(Zipkin)、运行时指标(InfluxDB、Prometheus、statsd) 分布式追踪(Zipkin)、运行时指标(statsd) 分布式追踪(Zipkin)、运行时指标(Prometheus、statsd)、监控(NewRepic、Stackdriver) 运行时指标(Prometheus) 部署模式 Sidecar 或者 per-host 模式 Sidecar 模式 Sidecar 模式 Sidecar 模式 控制平面 Namerd 没有，但可通过 API 实现。 Pilot、Mixer、Citadel Conduit 协议支持 HTTP/1.x、HTTP/2、gRPC HTTP/1.x、HTTP/2、gRPC、TCP HTTP/1.x、HTTP/2、gRPC、TCP HTTP/1.x、HTTP/2、gRPC、TCP 运行平台 平台无关 平台无关 目前支持Kubernetes，平台无关是最终实现目标。 只支持Kubernetes。 上述任何一个 Service Mesh 框架都能够满足您的基本需求。到⽬前为⽌，Istio 具有这几个服务⽹格框架中最多的功能和灵活性，灵活性意味着复杂性，因此需要团队更为充⾜的准备。如果只想使⽤基本的 Service Mesh 治理功能，Linkerd 可能是最佳选择。如果您想⽀持同时包含 Kubernetes 和 VM 的异构环境，并且不需要 Istio 的复杂性，那么 Conduit 可能是您的最佳选择，⽬前 Istio 也提供了同时包含 Kubernetes 和 VM 的异构环境的⽀持。 Copyright © xcbeyond.cn 2021 all right reserved，powered by Gitbook Updated at 2021-09-21 15:04:39 "},"architecture/istio-architecture.html":{"url":"architecture/istio-architecture.html","title":"Istio 整体架构","keywords":"","body":"Istio 整体架构 Copyright © xcbeyond.cn 2021 all right reserved，powered by Gitbook Updated at 2021-09-05 12:47:59 "},"architecture/dataplane.html":{"url":"architecture/dataplane.html","title":"数据平面","keywords":"","body":"数据平面 Copyright © xcbeyond.cn 2021 all right reserved，powered by Gitbook Updated at 2021-09-05 12:47:59 "},"architecture/controlplane.html":{"url":"architecture/controlplane.html","title":"控制平面","keywords":"","body":"控制平面 Copyright © xcbeyond.cn 2021 all right reserved，powered by Gitbook Updated at 2021-09-05 12:47:59 "},"install/istio-install.html":{"url":"install/istio-install.html","title":"Istio 安装","keywords":"","body":"Istio 安装 Copyright © xcbeyond.cn 2021 all right reserved，powered by Gitbook Updated at 2021-09-05 12:47:59 "},"install/istio-uninstall.html":{"url":"install/istio-uninstall.html","title":"Istio 卸载","keywords":"","body":"Istio 卸载 Copyright © xcbeyond.cn 2021 all right reserved，powered by Gitbook Updated at 2021-09-05 12:47:59 "},"install/deployment-bookinfo-application.html":{"url":"install/deployment-bookinfo-application.html","title":"部署示例","keywords":"","body":"部署示例 Copyright © xcbeyond.cn 2021 all right reserved，powered by Gitbook Updated at 2021-09-05 12:47:59 "},"install/istio-upgrade.html":{"url":"install/istio-upgrade.html","title":"升级","keywords":"","body":"升级 Copyright © xcbeyond.cn 2021 all right reserved，powered by Gitbook Updated at 2021-09-05 12:47:59 "},"traffic/config/":{"url":"traffic/config/","title":"资源配置","keywords":"","body":"资源配置 Istio 的流量管理是通过一系列的 CRD（Kubernetes 的自定义资源）来实现的，包括以下这些资源： VirtualService：虚拟服务，用来定义路由规则，控制请求如何被路由到某个服务。 DestinationRule：目标规则，用来配置请求策略。 Gateway：网关，在网格的入口设置负载、控制流量等。 ServiceEntry：服务入口，用来定义外部如何访问服务网格。 EnvoyFilter： Sidecar： Copyright © xcbeyond.cn 2021 all right reserved，powered by Gitbook Updated at 2021-09-20 08:54:14 "},"traffic/config/virtual-service.html":{"url":"traffic/config/virtual-service.html","title":"VirtualService","keywords":"","body":"VirtualService VirtualService 与 DestinationRule 是流量控制最关键的两个自定义资源。在 VirtualService 中定义了一组路由规则，当流量进入时，逐个规则进行匹配，直到匹配成功后将流量转发给指定的路由地址。 图 6.1.1.1：VirtualService流程图 示例 （以 Bookinfo 示例，将 Reviews 服务路由到v1版本） apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: reviews spec: hosts: - reviews http: - route: - destination: host: reviews subset: v1 --- apiVersion: networking.istio.io/v1alpha3 kind: DestinationRule metadata: name: reviews spec: host: reviews subsets: - name: v1 labels: version: v1 配置项说明： hosts：用来配置下游访问的可寻址地址。配置一个 String[] 类型的值，可以配置多个。指定了发送流量的目标主机， 可以使用FQDN（Fully Qualified Domain Name - 全限定域名）或者短域名， 也可以一个前缀匹配的域名格式或者一个具体的 IP 地址。 match：这部分用来配置路由规则，通常情况下配置一组路由规则，当请求到来时，自上而下依次进行匹配，直到匹配成功后跳出匹配。它可以对请求的 uri、method、authority、headers、port、queryParams 以及是否对 uri 大小写敏感等进行配置。 route：用来配置路由转发目标规则，可以指定需要访问的 subset （服务子集），同时可以对请求权重进行设置、对请求头、响应头中数据进行增删改等操作。subset （服务子集）是指同源服务而不同版本的 Pod，通常在 Deployment 资源中设置不同的 label 来标识。 更多详细配置项说明参考：https://istio.io/latest/zh/docs/reference/config/networking/virtual-service/#VirtualService Copyright © xcbeyond.cn 2021 all right reserved，powered by Gitbook Updated at 2021-09-20 08:54:14 "},"traffic/config/destination-rule.html":{"url":"traffic/config/destination-rule.html","title":"DestinationRule","keywords":"","body":"DestinationRule DestinationRule 是 Istio 中定义的另外一个比较重要的资源，它定义了网格中某个 Service 对外提供服务的策略及规则，包括负载均衡策略、异常点检测、熔断控制、访问连接池等。 负载均衡策略支持简单的负载策略（ROUND_ROBIN、LEAST_CONN、RANDOM、PASSTHROUGH）、一致性 Hash 策略和区域性负载均衡策略。 异常点检测配置在服务连续返回了5xx的错误时进行及时的熔断保护，避免引起雪崩效应。DestinationRule 也可以同 VirtualService 配合使用实现对同源服务不同子集服务的访问配置。 Copyright © xcbeyond.cn 2021 all right reserved，powered by Gitbook Updated at 2021-09-20 08:54:14 "},"traffic/config/gateway.html":{"url":"traffic/config/gateway.html","title":"Gateway","keywords":"","body":"Gateway Gateway，一个运行在网格边缘的负载均衡器，定义了所有 HTTP/TCP 流量进出服务网格的统一进出口。它描述了一组对外公开的端口、协议、负载均衡、以及 SNI 配置。 Istio Gateway 包括 Ingress Gateway 与 Egress Gateway，分别用来配置网格的入口流量与出口流量。Ingress Gateway 使用 istio-ingressgateway 负载均衡器来代理流量，而 istio-ingressgateway 实际上是一个 Envoy 代理。 图 6.1.3.1：Gateway流程图 示例 一个简单示例如下： apiVersion: networking.istio.io/v1alpha3 kind: Gateway metadata: name: my-gateway namespace: some-config-namespace spec: selector: app: my-gateway-controller servers: - port: number: 80 name: http protocol: HTTP hosts: - uk.bookinfo.com - eu.bookinfo.com tls: httpsRedirect: true # sends 301 redirect for http requests - port: number: 443 name: https-443 protocol: HTTPS hosts: - uk.bookinfo.com - eu.bookinfo.com tls: mode: SIMPLE # enables HTTPS on this port serverCertificate: /etc/certs/servercert.pem privateKey: /etc/certs/privatekey.pem - port: number: 9443 name: https-9443 protocol: HTTPS hosts: - \"bookinfo-namespace/*.bookinfo.com\" tls: mode: SIMPLE # enables HTTPS on this port credentialName: bookinfo-secret # fetches certs from Kubernetes secret - port: number: 9080 name: http-wildcard protocol: HTTP hosts: - \"ns1/*\" - \"ns2/foo.bar.com\" - port: number: 2379 # to expose internal service via external port 2379 name: mongo protocol: MONGO hosts: - \"*\" 该示例中， Gateway 被引用在 some-config-namespace 这个 Namespace 下，并使用 label my-gateway-controller 来关联部署网络代理的 Pod ，对外公开了 80、443、9443、9080、2379 端口的服务。 80 端口：附属配置的 host 为uk.bookinfo.com，eu.bookinfo.com，同时在 tls 中配置了 httpsRedirect。如果使用 HTTP1.1 协议访问将会返回 301，要求使用 HTTPS 访问，通过这种配置变相的禁止了对 uk.bookinfo.com，eu.bookinfo.com 域名的 HTTP1.1 协议的访问入口。 443 端口：提供TLS/HTTPS 的访问，表示接受 uk.bookinfo.com，eu.bookinfo.com 域名的 HTTPS 协议的访问，protocol 属性指定了协议类型。在 tls 的配置中指定了会话模式为单向 TLS（mode: SIMPLE） ，同时指定了服务端证书和私钥的存放地址。 9443 端口：提供TLS/HTTPS 的访问，与 443 端口不同的是证书不是指定存放证书文件的地址，而是通过 credentialName 属性配置从 Kubernetes 的证书管理中心拉取证书。 9080 端口：提供简单的 HTTP1.1 协议的访问。 hosts 中配置了 ns1/* 与 ns2/foo.bar.com，表示只允许ns1 Namespace 下的 VirtualService 绑定它以及 ns2 Namespace下配置了 host 为 foo.bar.com 的 VirtualService 绑定它。 2379 端口：提供 MONGO 协议的访问，允许所有 host 绑定它。 Egress Gateway 提供了对网格的出口流量进行统一管控的功能，在安装 Istio 时默认是不开启的。可以使用以下命令查看是否开启： kubectl get pod -l istio=egressgateway -n istio-system 若没有开启，使用以下命令添加。 istioctl manifest apply --set values.global.istioNamespace=istio-system \\ --set values.gateways.istio-egressgateway.enabled=true Egress Gateway 的一个简单示例如下： apiVersion: networking.istio.io/v1alpha3 kind: Gateway metadata: name: istio-egressgateway spec: selector: istio: egressgateway servers: - port: number: 80 name: http protocol: HTTP hosts: - edition.cnn.com 可以看出，与 Ingress Gateway不同，Egress Gateway 使用有 istio: egressgateway 标签的 Pod 来代理流量，实际上这是一个 Envoy 代理。当网格内部需要访问 edition.cnn.com 这个地址时，流量将会统一先转发到 Egress Gateway 上，再由 Egress Gateway 将流量转发到 edition.cnn.com 上。 Copyright © xcbeyond.cn 2021 all right reserved，powered by Gitbook Updated at 2021-09-20 08:54:14 "},"traffic/config/service-entry.html":{"url":"traffic/config/service-entry.html","title":"ServiceEntry","keywords":"","body":"ServiceEntry ServiceEntry ，将网格外的服务注册到 Istio 的注册表中，这样就可以把外部服务当做网格内部的服务一样进行管理和操作。包括服务发现、路由控制等，在 ServiceEntry 中可以配置 hosts，vips，ports，protocols，endpoints等。 图 6.1.4.1：ServiceEntry流程图 示例 它的一个简单示例如下： apiVersion: networking.istio.io/v1alpha3 kind: ServiceEntry metadata: name: external-svc-https spec: hosts: - api.dropboxapi.com - www.googleapis.com - api.facebook.com location: MESH_EXTERNAL ports: - number: 443 name: https protocol: TLS resolution: DNS 该示例中，定义了在网格内部使用 HTTPS 协议访问外部的几个服务的配置。通过上面配置，网格内部的服务就可以把 api.dropboxapi.com，www.googleapis.com, www.googleapis.com 这几个外部的服务当做网格内部服务去访问。MESH_EXTERNAL 表示是网格外服务，该参数会影响到服务间调用的 mTLS 认证、策略执行等。 Copyright © xcbeyond.cn 2021 all right reserved，powered by Gitbook Updated at 2021-09-20 08:54:14 "},"traffic/config/envoy-filter.html":{"url":"traffic/config/envoy-filter.html","title":"EnvoyFilter","keywords":"","body":"EnvoyFilter Copyright © xcbeyond.cn 2021 all right reserved，powered by Gitbook Updated at 2021-09-20 08:54:14 "},"traffic/config/sidecar.html":{"url":"traffic/config/sidecar.html","title":"Sidecar","keywords":"","body":"Sidecar 默认情况下，Istio 让每个 Envoy 代理都可以访问来自和它关联的应用服务的所有端口请求，然后转发到对应的应用服务。而通过 Sidecar 资源配置可以做更多的事情，如： 调整 Envoy 代理接受的端口和协议集。 限制 Envoy 代理可以访问的服务集合。 例如，下面的 Sidecar 配置将 bookinfo 命名空间中的所有服务配置为仅能访问运行在相同命名空间和 Istio 控制平面中的服务： apiVersion: networking.istio.io/v1alpha3 kind: Sidecar metadata: name: default namespace: bookinfo spec: egress: - hosts: - \"./*\" - \"istio-system/*\" Copyright © xcbeyond.cn 2021 all right reserved，powered by Gitbook Updated at 2021-09-20 08:54:14 "},"extensibility/extending-envoy-proxy-with-webassembly.html":{"url":"extensibility/extending-envoy-proxy-with-webassembly.html","title":"基于 WASM 扩展 Envoy","keywords":"","body":"基于 WASM 扩展 Envoy Copyright © xcbeyond.cn 2021 all right reserved，powered by Gitbook Updated at 2021-09-21 15:06:34 "},"integration/consul/integration-consul.html":{"url":"integration/consul/integration-consul.html","title":"集成 Consul","keywords":"","body":"集成 Consul Copyright © xcbeyond.cn 2021 all right reserved，powered by Gitbook Updated at 2021-09-21 15:06:34 "}}